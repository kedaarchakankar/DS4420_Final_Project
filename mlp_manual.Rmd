---
title: "MLP Algorithm to Predict Vitamin C Levels"
author: "Jonathan Hong"
date: "2025-12-01"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Read in Data

```{r data}
# read in data (preprocessed already)
y_train <- read.csv('y_train.csv')
y_test <- read.csv('y_test.csv')
X_train <- read.csv('features_train.csv')
X_test <- read.csv('features_test.csv')

# remove index columns and convert y to vectors
X_train <- X_train[,2:7]
X_test <- X_test[, 2:7]
y_train <- y_train$VitaminC
y_test <- y_test$VitaminC

head(X_train)
```

## Define activation functions

```{r functions}
# ReLU function
relu <- function(x) {
  matrix(pmax(0, x))
}

# post-activation function (to make the forward and backward pass smoother)
h <- function(w, x) { # w is weight matrix, x is input
  return(relu(t(w) %*% x))
}

# prediction function (relu on output)
f <- function(x,w1,w2,w3){
  h1 <- relu(t(w1) %*% x)
  h2 <- relu(t(w2) %*% h1)
  return(relu(t(w3) %*% h2))
}
```

## Neural Network Anatomy

Input: 6 features -> 6x1 vector

First layer: 12 nodes

Second layer: 5 nodes

Output: 1 scalar value


Objective function: Mean Squared Error (MSE)

Weights:
W1: 6x12 matrix
W2: 12x5 matrix
W3: 5x1 vector

```{r hyperparameters}
# initialize weights
W1 <- matrix(rnorm(6*12), nrow=6, ncol=12)
W2 <- matrix(rnorm(12*5), nrow=12, ncol=5)
W3 <- matrix(rnorm(5*1), nrow=5, ncol=1)

# set up other parameters
step <- 0.02
runs <- 100
n <- nrow(X_train)

```

## Run gradient descent
dL/dW3: (2/n) * sum((f(x) - y_i)) * (h2 * 1_{f(x)>0})

dL/dW2: (2/n) * sum((f(x) - y_i)) * 1_{f(x)>0} * kronecker(h1, (W3 * 1_{h2>0})^T)

dL/dW1: (2/n) * sum((f(x) - y_i)) * 1_{f(x)>0} * x((W2(W3 * 1_{h2>0}) * 1_{h1>0})^T)

```{r training, cache=TRUE}
# run gradient descent
errors <- numeric()

for (run in 1:runs) {
  # initialize weight derivatives
  dW3 <- matrix(0, nrow=5, ncol=1)  
  dW2 <- matrix(0, nrow=12, ncol=5)
  dW1 <- matrix(0, nrow=6, ncol=12)
  loss_sum <- 0 # total loss for the run  
  
  
  # compute derivatives
  for (i in 1:n) {
    x <- t(as.matrix(X_train[i, ]))

    # single forward pass
    y_hat <- f(x, W1, W2, W3)     # training output
    loss <- y_hat - y_train[i]    # loss on that term
    
    if (is.na(loss)) {
      cat("NA in loss at i =", i, "\n")
      cat("y_hat:", y_hat, "y_train[i]:", y_train[i], "\n")
      break
    }
    
    loss_sum <- loss_sum + loss^2 # total loss for the run, updated with each loop
    
    h1 <- h(W1, x)
    h2 <- h(W2, h1)
    
    mat1 <- ifelse(t(W1)%*%x>0, 1, 0)
    mat2 <- ifelse(t(W2)%*%h1>0, 1, 0)
    mat3 <- as.numeric(ifelse(t(W3)%*%h2>0, 1, 0)) # scalar
    dfdw1 <- x %*% t((W2 %*% (W3 * mat2)) * mat1)
    
    
    # sum up derivatives
    dW3 <- dW3 + ((2/n)* loss[1] * (h2 * mat3)) 
    dW2 <- dW2 + ((2/n)* loss[1] * mat3 * (kronecker(h1, t(W3 * mat2))))
    dW1 <- dW1 + ((2/n) * loss[1] * mat3 * dfdw1)
    
  }
  
  # update weights together
  W3 <- W3 - (step*dW3)
  W2 <- W2 - (step*dW2)
  W1 <- W1 - (step*dW1)
  
  # record error
  e <- loss_sum / n
  errors <- c(errors, e)
  
  # live update for each run
  cat("Epoch", run, "Complete", "\n")
}

```

## Predictions on test set
```{r predictions}
# predict on test set
y_pred <- c()
n_test <- nrow(X_test)
for(i in 1:n_test) {
    x <- t(as.matrix(X_test[i, ]))
    y_pred <- c(y_pred, f(x, W1, W2, W3))
}

# evaluate prediction accuracy
mse <- mean((y_pred - y_test)^2)
rmse <- sqrt(mse)
mae <- mean(abs(y_pred - y_test))
r2 <- 1 - (sum((y_test- y_pred)^2) / sum((y_test - mean(y_test))^2))

mse
rmse
mae
r2

```
## Plotting Results

```{r plots}
# plot errors
plot(1:runs, errors, type = 'l', main='MSE over runs', xlab = 'Number of runs', ylab='Error')

# plot predictions vs. true values (subset for visibility)
plot(1:n_test, y_pred, type="l", ylab="Vitamin C", xlab='Food Number', main='Vitamin C Predictions vs. Actual (first 100 rows)', ylim=range(c(0, 100)), xlim=range(c(0, 100)), col='blue')
lines(1:n_test, y_test, type="l", col='red')
legend("topright", legend=c("Predicted", "Actual"), col=c("blue", "red"), lty=1, cex=0.8)

# full predictions vs. true values plot
plot(1:n_test, y_pred, type="l", ylab="Vitamin C", xlab='Food Number', main='Vitamin C Predictions vs. Actual', ylim=range(c(y_test, y_pred)), col='blue')
lines(1:n_test, y_test, type="l", col='red')
legend("topright", legend=c("Predicted", "Actual"), col=c("blue", "red"), lty=1, cex=0.8)
```